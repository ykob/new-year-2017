/**
 * Modules in this bundle
 * @license
 * 
 * demofiles:
 * 
 * This header is generated by licensify (https://github.com/twada/licensify)
 */
!function n(e,t,r){function i(o,u){if(!t[o]){if(!e[o]){var d="function"==typeof require&&require;if(!u&&d)return d(o,!0);if(a)return a(o,!0);var c=new Error("Cannot find module '"+o+"'");throw c.code="MODULE_NOT_FOUND",c}var s=t[o]={exports:{}};e[o][0].call(s.exports,function(n){var t=e[o][1][n];return i(t?t:n)},s,s.exports,n,e,t,r)}return t[o].exports}for(var a="function"==typeof require&&require,o=0;o<r.length;o++)i(r[o]);return i}({1:[function(n,e,t){"use strict";function r(n){return n&&n.__esModule?n:{"default":n}}function i(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}var a=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),o=n("./modules/PostEffect.js"),u=r(o),d=function(){function n(){i(this,n),this.loader=new THREE.OBJLoader,this.uniforms={time:{type:"f",value:0}},this.mesh=null,this.instances=1e3}return a(n,[{key:"load",value:function(n){var e=this;this.loader.load("/obj/big_chicken.obj",function(t){e.mesh=e.createMesh(e.createGeometry(t)),n&&n()})}},{key:"createGeometry",value:function(n){for(var e=new THREE.InstancedBufferGeometry,t=[],r=[],i=[],a=0;a<n.children.length;a++)Array.prototype.push.apply(t,n.children[a].geometry.getAttribute("position").array),Array.prototype.push.apply(r,n.children[a].geometry.getAttribute("normal").array),Array.prototype.push.apply(i,n.children[a].geometry.getAttribute("uv").array);var o=new Float32Array(t),u=new Float32Array(r),d=new Int16Array(i);e.addAttribute("position",new THREE.BufferAttribute(o,3)),e.addAttribute("normal",new THREE.BufferAttribute(u,3)),e.addAttribute("uv",new THREE.BufferAttribute(d,2));for(var c=new THREE.InstancedBufferAttribute(new Float32Array(3*this.instances),3,1),s=new THREE.InstancedBufferAttribute(new Float32Array(3*this.instances),3,1),a=0,f=c.count;a<f;a++)c.setXYZ(a,Math.random()-.5,Math.random()-.5,Math.random()-.5),s.setXYZ(a,Math.random()-.5,Math.random()-.5,Math.random()-.5);return e.addAttribute("offset",c),e.addAttribute("rotate",s),e}},{key:"createMesh",value:function(n){return new THREE.Mesh(n,new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:"#define GLSLIFY 1\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec3 offset;\nattribute vec3 rotate;\n\nuniform mat4 projectionMatrix;\nuniform mat4 modelViewMatrix;\nuniform float time;\n\nvarying vec3 vNormal;\n\nmat4 translateMatrix(vec3 v) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    v.x, v.y, v.z, 1.0\n  );\n}\n\nmat4 rotateMatrixX(float radian) {\n  return mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, cos(radian), -sin(radian), 0.0,\n    0.0, sin(radian), cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotateMatrixY(float radian) {\n  return mat4(\n    cos(radian), 0.0, sin(radian), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    -sin(radian), 0.0, cos(radian), 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotateMatrixZ(float radian) {\n  return mat4(\n    cos(radian), -sin(radian), 0.0, 0.0,\n    sin(radian), cos(radian), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n  );\n}\n\nmat4 rotateMatrix(float radX, float radY, float radZ) {\n  return rotateMatrixX(radX) * rotateMatrixY(radY) * rotateMatrixZ(radZ);\n}\n\nvoid main(void) {\n  float radian = radians(time);\n  vec4 updatePosition =\n    rotateMatrix(radian * 5.0 + rotate.x, radian * 20.0 + rotate.y, radian + rotate.z)\n    * translateMatrix(offset * 60000.0 + offset * sin(radian + rotate.x * 10.0) * 40000.0)\n    * rotateMatrix(radian * rotate.x * 100.0, radian * rotate.y * 100.0, radian * rotate.z * 100.0)\n    * vec4(position, 1.0);\n  vNormal = normal;\n  gl_Position = projectionMatrix * modelViewMatrix * updatePosition;\n}\n",fragmentShader:"precision highp float;\n#define GLSLIFY 1\n\nvarying vec3 vNormal;\n\nvec3 convertHsvToRgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(void) {\n  float h = dot(vNormal, vec3(1.0, 0.0, 0.0)) * 0.1 + 0.08;\n  vec3 color = convertHsvToRgb(vec3(h, 0.8, 1.0));\n  gl_FragColor = vec4(color, 1.0);\n}\n"}))}},{key:"render",value:function(n){this.uniforms.time.value+=n}}]),n}(),c=document.getElementById("canvas-webgl"),s=new THREE.WebGLRenderer({antialias:!1,canvas:c}),f=new THREE.WebGLRenderTarget(window.innerWidth,window.innerHeight),l=new THREE.Scene,v=new THREE.Scene,h=new THREE.OrthographicCamera((-1),1,1,(-1),0,1),m=new THREE.PerspectiveCamera(50,window.innerWidth/window.innerHeight,1,1e5),w=new THREE.Clock,p=new u["default"](f.texture),y=new d,E=function(){c.width=window.innerWidth,c.height=window.innerHeight,m.aspect=window.innerWidth/window.innerHeight,m.updateProjectionMatrix(),f.setSize(window.innerWidth,window.innerHeight),s.setSize(window.innerWidth,window.innerHeight)},g=function(){window.addEventListener("resize",function(){E()})},x=function(){y.render(w.getDelta()),s.render(v,m,f),p.render(w.getDelta()),s.render(l,h)},b=function H(){x(),requestAnimationFrame(H)},M=function(){s.setSize(window.innerWidth,window.innerHeight),s.setClearColor(15658734,1),m.position.set(0,0,2e4),m.lookAt(new THREE.Vector3),l.add(p.mesh),y.load(function(){v.add(y.mesh),g(),b()}),E()};M()},{"./modules/PostEffect.js":2}],2:[function(n,e,t){"use strict";function r(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),a=function(){function n(e){r(this,n),this.uniforms={time:{type:"f",value:0},resolution:{type:"v2",value:new THREE.Vector2(window.innerWidth,window.innerHeight)},texture:{type:"t",value:e}},this.mesh=this.createMesh(e),this.time=1}return i(n,[{key:"createMesh",value:function(){return new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),new THREE.RawShaderMaterial({uniforms:this.uniforms,vertexShader:"#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = vec4(position, 1.0);\n}\n",fragmentShader:"precision highp float;\n#define GLSLIFY 1\n\nuniform vec2 resolution;\nuniform sampler2D texture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec4 color = texture2D(texture, vUv);\n  gl_FragColor = color;\n}\n"}))}},{key:"render",value:function(n){this.uniforms.time.value+=n*this.time}},{key:"resize",value:function(){this.uniforms.resolution.value.set(window.innerWidth,window.innerHeight)}}]),n}();t["default"]=a},{}]},{},[1]);